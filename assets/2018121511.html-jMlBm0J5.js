import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as p,o as n,c as h,b as t,d,e as r,f as a}from"./app-5ZyUDSyM.js";const o="/assets/img-20230408100911-T1tQ8Vtv.png",l="/assets/img-20230408103009-HZT2n8h6.png",s="/assets/img-20230408103111-cKISdlox.png",c="/assets/img-20230408105526-zHByEh3l.png",b="/assets/img-20230408105648-zPs5n10w.png",g="/assets/img-20230408110613-uawRXyiP.png",f="/assets/img-20230408110753-78UoVlO-.png",u="/assets/img-20230408111136-fPxebVmM.png",_="/assets/img-20230408111243-xcc47gh9.png",S="/assets/img-20230408111356-ktdY7HZ9.png",m="/assets/img-20230408111544-DnIlYGmc.png",y="/assets/img-20230408113420-7BmdAXcX.png",x={},A=a('<p>​</p><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>说起架构，我们先看一下何为架构，百度百科是这样说的：架构，又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。那么我们也可以看出，架构是和业务紧密相关的，是由业务驱动的。</p><p>由于App客户端的特性，因此App后台对技术实现和一般的Web后台是有区别的。首先看一个适合App开发的开发模式：</p><h2 id="敏捷开发模式" tabindex="-1"><a class="header-anchor" href="#敏捷开发模式" aria-hidden="true">#</a> 敏捷开发模式</h2><p>这里推荐Scrum这个敏捷开发框架，具体可以查看Scrum官网学习使用，这里只是引入。</p><p>Scrum流程如下图：</p><figure><img src="'+o+'" alt="Scrum流程图" tabindex="0" loading="lazy"><figcaption>Scrum流程图</figcaption></figure><h2 id="选择合适的数据库产品和服务器系统" tabindex="-1"><a class="header-anchor" href="#选择合适的数据库产品和服务器系统" aria-hidden="true">#</a> 选择合适的数据库产品和服务器系统</h2><p>数据库产品众多，这里我就针对Redis、MongoDB、MySQL还有MySQL的分支MariaDB展开说明：</p><h3 id="_1-数据库产品" tabindex="-1"><a class="header-anchor" href="#_1-数据库产品" aria-hidden="true">#</a> 1. 数据库产品</h3><table><thead><tr><th>数据库</th><th>数据存放位置</th><th>查找数据的区别</th></tr></thead><tbody><tr><td>Redis</td><td>内存</td><td>基于键值对存储，读写速度快</td></tr><tr><td>MongoDB</td><td>同时使用了硬盘和内存</td><td>每个数据有一个id（索引），知道id（索引）查询速度快，不知道id（索引）效率低</td></tr><tr><td>MySQL（MongoDB）</td><td>硬盘</td><td>每个数据有一个id（索引），知道id（索引）查询速度快，不知道id（索引）效率低</td></tr></tbody></table><p>然后根据不同的产品需求选择恰当的数据库产品，如果没有特殊的需求，Redis做缓存系统，MySQL 或 MariaDB 做数据库（常见的设置是数据库默认字符集utf8，默认排序utf8_general_ci）将会是很好的选择。</p><p>软件优化：</p><ul><li>正确使用MyISAM和InnoDB存储引擎</li><li>正确使用索引</li><li>避免使用 select *</li><li>字段尽可能的设置非NULL</li></ul><p>硬件优化：</p><ul><li>增加物理内存</li><li>增加应用缓存</li><li>使用SSD硬盘</li></ul><p>架构优化：</p><ul><li>分表</li><li>读写分离</li></ul><figure><img src="'+l+'" alt="MySQL读写分离" tabindex="0" loading="lazy"><figcaption>MySQL读写分离</figcaption></figure><ul><li>分库（把一张表的数据分别存储在不同的数据库，可用MyCat实现，MyCat，关系型数据库分布式处理软件）。</li></ul><p>MyCat以代理服务器的形式位于App服务器和后台数据库之间，对外开放的接口是MySQL通信协议，将App服务器传过来的sql语句按照路由的规则拆解转发到不同的后台数据库，并把结果汇总返回。</p><p>MyCat部署模型如下：</p><figure><img src="'+s+'" alt="MyCat架构图" tabindex="0" loading="lazy"><figcaption>MyCat架构图</figcaption></figure><h3 id="_2-服务器系统" tabindex="-1"><a class="header-anchor" href="#_2-服务器系统" aria-hidden="true">#</a> 2. 服务器系统</h3><p>CentOS 则是一个不错的选择。关于服务器的部署，我在之前已经介绍过了，地址如下：</p>',26),T={href:"http://blog.csdn.net/smartbetter/article/details/53535435",target:"_blank",rel:"noopener noreferrer"},M=t("br",null,null,-1),L={href:"http://blog.csdn.net/smartbetter/article/details/53615313",target:"_blank",rel:"noopener noreferrer"},P=a('<p>下面补充两个常见的Linux命令：</p><p>top 显示系统资源情况<br> netstat 查看网络相关信息</p><h2 id="选择合适的消息队列软件" tabindex="-1"><a class="header-anchor" href="#选择合适的消息队列软件" aria-hidden="true">#</a> 选择合适的消息队列软件</h2><p>当后台系统发现完成某些小任务需要花费很多时间，而且迟点晚成也不影响整个任务的完成进度时，就会把这些小任务交给消息队列。例如发送邮件、短信、推送消息等任务都非常适合在消息队列中处理。</p><p>把这些任务放在消息队列中，可加快App后台请求都响应时间。同时消息队列也能把大量的并发请求变成串行的请求，来减轻服务器的负担。</p><p>常见的消息队列软件有：</p><table><thead><tr><th>消息队列软件</th><th>说明</th></tr></thead><tbody><tr><td>RabbitMQ</td><td>重量级，适合企业级的开发，自带Web监控界面，方便监控队列的情况</td></tr><tr><td>Redis</td><td>轻量级，是一个key-value系统，但是也支持消息队列这种数据结构，App后台中Redis被广泛使用</td></tr><tr><td>ZeroMQ</td><td>号称最快，尤其针对大吞吐量的需求场景</td></tr><tr><td>ActiveMQ</td><td>Apache的一个子项目，能够以代理人和点对点的技术实现队列</td></tr></tbody></table><h2 id="使用分布式服务实现业务的复用" tabindex="-1"><a class="header-anchor" href="#使用分布式服务实现业务的复用" aria-hidden="true">#</a> 使用分布式服务实现业务的复用</h2><p>随着业务不断增加，后台系统由一个单一应用膨胀为一个巨无霸系统，系统中聚合了大量的应用和服务，各个模块之间有很多功能重复实现（例如登录模块），造成了开发、运维、部署的麻烦。</p><figure><img src="'+c+'" alt="分布式服务架构图" tabindex="0" loading="lazy"><figcaption>分布式服务架构图</figcaption></figure><p>大量应用中的重复模块会带来大量的访问，而每个应用与数据库的连接，一般是使用数据库的连接池，这个连接池的资源一般是不释放且一直保留着。假设连接池中有10个连接，中一个数百的服务器集群中，就占用了数据库1000个连接。数据库中的每个连接都是十分珍贵的资源，在资源有限的情况下，这里被占用了，其他能用的资源就少了。</p><p>解决这些问题的方法就是把重复实现的模块独立部署为远程服务，新增的业务调用远程服务所提供的功能实现相关的业务，不依赖于里面具体的代码实现。</p><figure><img src="'+b+'" alt="分布式服务架构图2" tabindex="0" loading="lazy"><figcaption>分布式服务架构图2</figcaption></figure><p>实现远程服务可以参考 REST设计原则和 RPC远程调用协议。</p><p>开源的RPC库有：</p><table><thead><tr><th>开源的RPC库</th><th>说明</th></tr></thead><tbody><tr><td>Hprose</td><td>轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库</td></tr><tr><td>Dubbo</td><td>分布式服务框架，致力于提供高性能和透明化的RPC远程调用服务和SOA服务治理方案</td></tr></tbody></table><h2 id="用户验证方案最佳实践" tabindex="-1"><a class="header-anchor" href="#用户验证方案最佳实践" aria-hidden="true">#</a> 用户验证方案最佳实践</h2><p>App操作中经常涉及用户登录操作，登录就需要使用到用户名和密码，为了安全起见，在登录过程中暴漏密码的次数越少越好。</p><h3 id="_1-使用https协议" tabindex="-1"><a class="header-anchor" href="#_1-使用https协议" aria-hidden="true">#</a> 1. 使用HTTPS协议</h3><p>HTTPS协议是 HTTP协议和 SSL／TLS协议的组合。其是一个安全通信通道，基于HTTP开发，用于在客户计算机和App后台之间交换信息。其使用安全套接字层（SSL）进行信息交换，简单来说就是HTTP的安全版。</p><p>HTTPS实际上应用了安全套接字层（SSL）作为HTTP应用层的子层。</p><p>HTTPS的模型：</p><table><thead><tr><th style="text-align:center;">HTTP</th></tr></thead><tbody><tr><td style="text-align:center;">SSL／TLS（安全套接字层／传输层安全协议）</td></tr><tr><td style="text-align:center;">TCP</td></tr><tr><td style="text-align:center;">IP</td></tr><tr><td style="text-align:center;">网络传输</td></tr></tbody></table><p>避免信息的泄漏，最基本的方案是所有涉及安全性的API请求都必须使用HTTPS协议。</p><h3 id="_2-选择json作为数据交换格式" tabindex="-1"><a class="header-anchor" href="#_2-选择json作为数据交换格式" aria-hidden="true">#</a> 2. 选择JSON作为数据交换格式</h3><p>JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，易于编写，也易于机器解析和生成，而且对比XML更省流量，这些特性使得JSON成为理想的数据交换语言。</p><h3 id="_3-基本的用户验证方案" tabindex="-1"><a class="header-anchor" href="#_3-基本的用户验证方案" aria-hidden="true">#</a> 3. 基本的用户验证方案</h3><p>传统Web网站使用Cookie+Session保持用户的登录状态，App后台则使用token进行验证，流程如下：</p><figure><img src="'+g+'" alt="用户验证方案" tabindex="0" loading="lazy"><figcaption>用户验证方案</figcaption></figure><p>此时App已经获取到了token值，为了安全，我们不在网络上传输token，而使用签名校验（这里使用URL签名）的方式，API请求加上URL签名sign和用户id后如下：</p><p><code>test.com/user/update?uid=2&amp;sign=3f1e736bc4ae958ae7e8500b45aefdbb&amp;age=22</code></p><p>这样，token就不需要附在URL上了。App后台签名校验流程如下：</p><figure><img src="'+f+'" alt="App后台签名验证流程" tabindex="0" loading="lazy"><figcaption>App后台签名验证流程</figcaption></figure><p>还有的童鞋喜欢设置时间戳，这样时间一长，URL就失效了，也是一种不错的进一步的优化方案。</p><p><em>建议：为了保障数据安全，这里建议<strong>同时使用 HTTPS 和签名校验。</strong></em></p><h2 id="app后台架构的演进原则" tabindex="-1"><a class="header-anchor" href="#app后台架构的演进原则" aria-hidden="true">#</a> App后台架构的演进原则</h2><p>App后台的架构是由业务规模驱动而演进的，App后台是为业务服务的，App后台的价值在于能为业务提供其所需要的功能，不应过度设计。</p><p>从项目的角度，当App访问量不大时，应该快速搭建App后台，让App尽快上线给用户提供服务，验证商业模式的正确性，同时快速迭代产品。</p><p>当App访问量不断上升，这时要在保证快速迭代的前提下，同时兼顾高性能和高可用。</p><p>当App访问量达到一定阶段后，增长曲线就会放缓，但业务变得更加复杂，对高性能和高可用的要求也更高，性能问题、模块间的耦合、代码的复杂性会更加突出和明显，这时要使用业务拆分、分布式服务调用，甚至是技术转型等问题。</p><h3 id="_1-项目启动时——单机部署" tabindex="-1"><a class="header-anchor" href="#_1-项目启动时——单机部署" aria-hidden="true">#</a> 1. 项目启动时——单机部署</h3><p>我们看一个App后台极简化的架构：</p><figure><img src="'+u+'" alt="后台极简架构" tabindex="0" loading="lazy"><figcaption>后台极简架构</figcaption></figure><p>一开始就使用Redis的好处：</p><p>既能用作缓存，又能充当队列服务，而且并发性能高，能在长时间内应对业务压力，非常适合初期的项目。</p><p>这里使用Redis验证用户信息，充当消息队列。</p><p>而文件服务初期可以选择文件云存储服务，或者自己搭建一个资源服务器。</p><h3 id="_2-项目一定规模时——分布式部署" tabindex="-1"><a class="header-anchor" href="#_2-项目一定规模时——分布式部署" aria-hidden="true">#</a> 2. 项目一定规模时——分布式部署</h3><p>我们看一个百万级到千万级的架构：</p><figure><img src="'+_+'" alt="分布式架构" tabindex="0" loading="lazy"><figcaption>分布式架构</figcaption></figure><p>这里新增了专门用于连接内部服务器的SSH服务的外网通道，保证SSH操作随时可用，同时加入了服务器集群，提供负载能力。</p><p>随着业务的发展，某些数据表的规模会以几何级增长，当数据达到一定规模时，查询读取性能就下降的厉害，数据库主从的架构不能应对业务上的读写压力，这时架构上要考虑分表（水平拆分／垂直拆分）。</p><p>当业务继续不断发展，数据库分表后的读写性能也可能没法满足业务上的需求，这时只能采用进一步的拆分策略——分库。用 Cobar 或者 MyCat 等关系型数据等分布式处理系统后，分库后的架构如下：</p><figure><img src="'+S+'" alt="分库后的分布式架构" tabindex="0" loading="lazy"><figcaption>分库后的分布式架构</figcaption></figure><p>下来看一个真实社交App项目所采用的后台架构方案。</p><h2 id="社交-app-后台架构设计方案分享" tabindex="-1"><a class="header-anchor" href="#社交-app-后台架构设计方案分享" aria-hidden="true">#</a> 社交 App 后台架构设计方案分享</h2><p>场景：类似微博，用户与用户之间存在关注／粉丝两种关系，一个用户发表了新内容，关注他的用户也能在个人主页上收到最新的动态。类似微博这种场景：</p><figure><img src="'+m+'" alt="微博界面" tabindex="0" loading="lazy"><figcaption>微博界面</figcaption></figure><p>社交核心功能是 Feed（指用户通过关注，聚合了被关注用户的最新的内容，也包含自己的内容，以供自己浏览的信息服务）。</p><h3 id="_1-feed-基本表结构" tabindex="-1"><a class="header-anchor" href="#_1-feed-基本表结构" aria-hidden="true">#</a> 1. Feed 基本表结构</h3><p>常见的 Feed 架构是把数据存储在 MySQL，热点数据存储（一般最近3天）在缓存（Redis／Memcached），保证绝大多数请求通过缓存直接返回，只有少量请求穿透缓存落到数据库。</p><p>下面看一下最简单的 Feed 表结构：</p><ul><li><p>send_content：发送内容表，存储用户发表的内容：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>feed_id</td><td>发表的feed的id，主键自增</td></tr><tr><td>author_id</td><td>发表该feed的用户id</td></tr><tr><td>content</td><td>feed的内容</td></tr></tbody></table></li><li><p>reveive_content：接收内容表，用于推模式时存储用户接收的内容：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>feed_id</td><td>发表的feed的id，主键自增</td></tr><tr><td>author_id</td><td>发表该feed的用户id</td></tr><tr><td>reveive_id</td><td>接收该feed的用户id</td></tr><tr><td>content</td><td>feed的内容</td></tr></tbody></table></li><li><p>followings：关注表，存储用户关注的人：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>主键自增</td></tr><tr><td>uid</td><td>用户id</td></tr><tr><td>following_id</td><td>该用户关注的其他用户id</td></tr></tbody></table></li><li><p>followers：粉丝表，存储用户的粉丝：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>主键自增</td></tr><tr><td>uid</td><td>用户id</td></tr><tr><td>follower_id</td><td>关注该用户的用户id</td></tr></tbody></table></li></ul><h3 id="_2-feed-推拉模式——推模式用户发表一条内容的流程" tabindex="-1"><a class="header-anchor" href="#_2-feed-推拉模式——推模式用户发表一条内容的流程" aria-hidden="true">#</a> 2. Feed 推拉模式——推模式用户发表一条内容的流程</h3><ul><li><p>uid为1的用户发表一条内容 “HelloWorld” 信息。</p></li><li><p>这条内容写入发送内容表 “send_content” 后内容如下：</p><table><thead><tr><th>feed_id</th><th>author_id</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>HelloWorld</td></tr></tbody></table></li><li><p>在粉丝表 “followers” 查找uid为1用户的粉丝，粉丝表 “followers” 的内容如下：</p><table><thead><tr><th>id</th><th>uid</th><th>follower_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td></tr></tbody></table><p>可知，id为1用户的粉丝是id为2的用户。</p></li><li><p>因为id为2的用户的feed中需要显示这条内容，因此把内容写入接收内容表 “reveive_content”，写入后接受内容表 “reveive_content” 内容如下：</p><table><thead><tr><th>feed_id</th><th>author_id</th><th>reveive_id</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>HelloWorld</td></tr></tbody></table></li><li><p>当id为2的用户显示feed时，通过sql语句 “select * from reveive_content where reveive_id=2” 就能查询该用户需要显示的数据了。</p></li></ul><p>推模式的缺点是：</p><p>推送人数过大会出现延时，而且浪费存储空间；</p><p>更新操作成本大，不但变更 “send_content” 表，而且需要同步变更 “reveive_content” 表。</p><h3 id="_3-feed-推拉模式——拉模式用户发表一条内容的流程" tabindex="-1"><a class="header-anchor" href="#_3-feed-推拉模式——拉模式用户发表一条内容的流程" aria-hidden="true">#</a> 3. Feed 推拉模式——拉模式用户发表一条内容的流程</h3><ul><li><p>uid为5的用户发表一条内容 “Thinks” 信息。</p></li><li><p>这条内容写入发送内容表 “send_content” 后内容如下：</p><table><thead><tr><th>feed_id</th><th>author_id</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>HelloWorld</td></tr><tr><td>2</td><td>5</td><td>Thinks</td></tr></tbody></table></li><li><p>当uid为10的用户显示feed时，在关注表 “followings” 查找uid为10所关注的用户，关注表如下：</p><table><thead><tr><th>id</th><th>uid</th><th>following_id</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>5</td></tr></tbody></table><p>可知，uid为10的用户关注了uid为5的用户，因此需要获取uid为5的用户发表的内容。</p></li><li><p>uid为5的用户通过sql语句 “select * from send_content where author_id in (5)” 查询所以需要显示的内容。</p></li></ul><p>由上述可知，拉模式采用了时间换空间的策略，用户推送内容时效率很高，但当用户显示feed时，需要花费大量的时间在聚合运算上。</p><p>总结：</p><table><thead><tr><th>-</th><th>发表内容</th><th>显示feed</th><th>变更通知</th></tr></thead><tbody><tr><td>推模式</td><td>推送给所有粉丝</td><td>一个sql语句就能完成</td><td>变更成本高</td></tr><tr><td>拉模式</td><td>不推送</td><td>需要大量的聚合运算</td><td>无变更成本</td></tr></tbody></table><p>像 “微博” 中公开的微博采用拉模式，私密性的微博采用推模式。</p><p>拉模式最大的问题就是大量的聚合运算，请求的响应时间可能较长，可以通过缓存策略让大部分的请求的响应时间达到2到3毫秒。</p><h2 id="其他的一些经验" tabindex="-1"><a class="header-anchor" href="#其他的一些经验" aria-hidden="true">#</a> 其他的一些经验</h2><h3 id="_1-高效更新数据——内容的推拉" tabindex="-1"><a class="header-anchor" href="#_1-高效更新数据——内容的推拉" aria-hidden="true">#</a> 1. 高效更新数据——内容的推拉</h3><p>平常App设计中，如果App需要知道首页是否有内容更新，通过一个轮询机制访问获取数据API，从API是否返回更新的数据得知是否有内容更新，轮询上很典型的拉模式，但是耗电、耗流量。</p><p>怎么减少轮询呢？这里给出解决方案是推模式，如下图：</p><figure><img src="'+y+'" alt="推模式" tabindex="0" loading="lazy"><figcaption>推模式</figcaption></figure><p>当然不能只用推模式，因为手机环境的复杂性，不能保证数据更新的通知一定能够到达App，所以也要采用轮询的方式定期拉数据，时间间隔设置可以相对长一点，通过这种推拉结合的模式，就能大大减少App访问App后台的频率和传输的数据量。</p><h3 id="_2-处理表情的一些技巧" tabindex="-1"><a class="header-anchor" href="#_2-处理表情的一些技巧" aria-hidden="true">#</a> 2. 处理表情的一些技巧</h3><p>表情在MySQL的存储，表情UTF-8编码有的是3个字节，有的是4个字节，所以一般的UTF编码（3个字节）是无法存储表情数据的，常用的解决方案是：</p><p>把MySQL升级到5.5以上，然后把字符编码改为utf8mb4_general_ci。</p><h3 id="_3-可供选择的成熟稳定的开源软件" tabindex="-1"><a class="header-anchor" href="#_3-可供选择的成熟稳定的开源软件" aria-hidden="true">#</a> 3. 可供选择的成熟稳定的开源软件</h3><table><thead><tr><th>功能</th><th>可供选择的开源软件</th></tr></thead><tbody><tr><td>项目管理软件</td><td>Mantis、BugFree</td></tr><tr><td>代码管理软件</td><td>SVN、Git</td></tr><tr><td>编程语言</td><td>Java、PHP、Python等</td></tr><tr><td>服务器系统</td><td>CentOS、Ubuntu</td></tr><tr><td>HTTP／HTTPS服务器</td><td>Nginx、Tomcat、Apache</td></tr><tr><td>负载均衡</td><td>Nginx、LVS、HAProxy</td></tr><tr><td>邮件服务</td><td>Postfix、Sendmail</td></tr><tr><td>消息队列</td><td>RabbitMQ、ZeroMQ、Redis</td></tr><tr><td>文件系统</td><td>Fastdfs、mogileFS、TFS</td></tr><tr><td>Android推送</td><td>Androidpn、gopush</td></tr><tr><td>IOS推送</td><td>Javapns、Pyapns</td></tr><tr><td>地理位置查询LBS</td><td>MongoDB</td></tr><tr><td>聊天</td><td>Openfire、ejobberd</td></tr><tr><td>监控</td><td>ngiOS、zabbix</td></tr><tr><td>缓存</td><td>Memcache、Redis</td></tr><tr><td>关系型数据库</td><td>MySQL、MariaDB、PostgreSQL</td></tr><tr><td>NoSQL数据库</td><td>Redis、MongoDB、Cassandra</td></tr><tr><td>搜索</td><td>Coreseek、Solr、ElasticSearch</td></tr><tr><td>图片处理</td><td>GraphicsMagick、ImageMagick</td></tr><tr><td>分布式访问服务</td><td>dubbo、dubbox</td></tr></tbody></table><h3 id="_3-可供选择的成熟可靠的云服务" tabindex="-1"><a class="header-anchor" href="#_3-可供选择的成熟可靠的云服务" aria-hidden="true">#</a> 3. 可供选择的成熟可靠的云服务</h3><p>对于初创公司还是建议尽可能的使用成熟可靠的云服务和开源软件，自身只专注于业务逻辑。</p><table><thead><tr><th>功能</th><th>可供选择的云服务</th></tr></thead><tbody><tr><td>项目管理工具</td><td>Teambition、Tower</td></tr><tr><td>代码托管平台</td><td>GitHub、Gitlab、Bitbucket、CSDN CODE、Coding</td></tr><tr><td>负载均衡</td><td>阿里云SLB、腾讯云CLB</td></tr><tr><td>邮件服务</td><td>SendCloud、MailGun</td></tr><tr><td>消息队列</td><td>阿里云MNS、腾讯云CMQ</td></tr><tr><td>文件系统、图片处理</td><td>七牛云、阿里云对象存储OSS、腾讯云对象存储COS</td></tr><tr><td>Android推送</td><td>极光、个推、百度推送</td></tr><tr><td>IOS推送</td><td>极光、个推、百度推送</td></tr><tr><td>聊天</td><td>融云、环信</td></tr><tr><td>监控</td><td>监控宝、云服务器自带的监控服务</td></tr><tr><td>缓存</td><td>阿里云缓存服务、腾讯云弹性缓存</td></tr><tr><td>关系型数据库</td><td>阿里云RDS、腾讯云CDB</td></tr><tr><td>NoSQL数据库</td><td>阿里云NoSQL产品、腾讯云NoSQL产品</td></tr><tr><td>搜索</td><td>阿里云开放搜索、腾讯云搜TCS</td></tr><tr><td>分布式访问服务</td><td>阿里云EDAS</td></tr><tr><td>防火墙</td><td>阿里云云盾、腾讯云安全</td></tr><tr><td>短信发送</td><td>shareSDK、bmob、Luosimao</td></tr><tr><td>社交登录分享</td><td>shareSDK</td></tr></tbody></table><p>最后，在移动互联网项目中，产品的研发讲求小步快走，快速迭代。架构的设计也可以遵循同样的思路，喜欢本文的记得顶一下哦！</p><hr>',91),C={href:"http://blog.csdn.net/smartbetter/article/details/53933096",target:"_blank",rel:"noopener noreferrer"};function H(v,R){const e=p("ExternalLinkIcon");return n(),h("div",null,[A,t("p",null,[t("a",T,[d("Nginx + Tomcat 反向代理负载均衡集群部署指南"),r(e)]),M,t("a",L,[d("Nginx + Tomcat 反向代理如何在高效的在一台服务器部署多个站点"),r(e)])]),P,t("p",null,[d("原文链接："),t("a",C,[d("http://blog.csdn.net/smartbetter/article/details/53933096"),r(e)])])])}const B=i(x,[["render",H],["__file","2018121511.html.vue"]]);export{B as default};
